#!/usr/bin/env python

# wujian@2018
"""
Compute directional features using steer vector, based on TF-mask
"""

import argparse

import numpy as np

from libs.utils import nfft, get_logger
from libs.opts import get_stft_parser
from libs.spatial import directional_feats
from libs.data_handler import SpectrogramReader, ScriptReader, NumpyReader, ArchiveWriter
from libs.beamformer import MvdrBeamformer

logger = get_logger(__name__)


def run(args):
    stft_kwargs = {
        "frame_length": args.frame_length,
        "frame_shift": args.frame_shift,
        "window": args.window,
        "center": args.center,  # false to comparable with kaldi
        "transpose": False  # F x T
    }
    feat_reader = SpectrogramReader(args.wav_scp, **stft_kwargs)
    mask_reader = NumpyReader(args.mask_scp) if args.numpy else ScriptReader(
        args.mask_scp)

    num_bins = nfft(args.frame_length) // 2 + 1
    beamformer = MvdrBeamformer(num_bins)

    num_done = 0
    with ArchiveWriter(args.dup_ark, args.scp) as writer:
        for key, spect in feat_reader:
            if key in mask_reader:
                speech_masks = mask_reader[key]
                if args.trans:
                    speech_masks = np.transpose(speech_masks)
                speech_masks = np.minimum(speech_masks, 1)
                # spectrogram: N x F x T
                speech_covar = beamformer.compute_covar_mat(
                    speech_masks, spect)
                sv = beamformer.compute_steer_vector(speech_covar)
                df = directional_feats(spect, sv.T)
                writer.write(key, df)
                num_done += 1
                if not num_done % 1000:
                    logger.info("Processed {:d} utterance...".format(num_done))
            else:
                logger.warn("Missing TF-mask for utterance {}".format(key))
    logger.info("Processed {:d} utterances over {:d}".format(
        num_done, len(feat_reader)))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=
        "Command to compute directional features, based on estimated TF-masks",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        parents=[get_stft_parser()])
    parser.add_argument(
        "wav_scp", type=str, help="Multi-Channel wave scripts in kaldi format")
    parser.add_argument(
        "mask_scp",
        type=str,
        help="Scripts of masks generated by kaldi's networks"
        "(default)/numpy's ndarray(add --numpy)")
    parser.add_argument(
        "dup_ark",
        type=str,
        help="Location to dump features in kaldi's archives")
    parser.add_argument(
        "--scp",
        type=str,
        default="",
        help="If assigned, generate corresponding feature scripts")
    parser.add_argument(
        "--numpy",
        action="store_true",
        help="Define type of masks in numpy.ndarray instead of "
        "kaldi's archives")
    parser.add_argument(
        "--transpose-mask",
        dest="trans",
        action="store_true",
        help="If true, reshape mask from FxT to TxF"
        "(T: num_frames, F: num_bins)")
    args = parser.parse_args()
    run(args)